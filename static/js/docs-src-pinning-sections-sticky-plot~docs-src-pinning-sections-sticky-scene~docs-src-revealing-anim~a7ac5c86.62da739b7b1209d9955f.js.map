{"version":3,"sources":["/Users/garfieldduck/Documents/Projects/SelfProject/react-scrolly/docs/src/components/CenterBox.jsx","/Users/garfieldduck/Documents/Projects/SelfProject/react-scrolly/docs/src/components/DemoWrapper.jsx","/Users/garfieldduck/Documents/Projects/SelfProject/react-scrolly/docs/src/config/media-queries.js","/Users/garfieldduck/Documents/Projects/SelfProject/react-scrolly/docs/src/config/theme.js","/Users/garfieldduck/Documents/Projects/SelfProject/react-scrolly/packages/core/src/context/PageContext.ts","/Users/garfieldduck/Documents/Projects/SelfProject/react-scrolly/packages/core/src/utils/getScrollPosition.ts","/Users/garfieldduck/Documents/Projects/SelfProject/react-scrolly/packages/core/src/hooks/page/useActiveSectionTracker.ts","/Users/garfieldduck/Documents/Projects/SelfProject/react-scrolly/packages/core/src/components/PageProvider.tsx","/Users/garfieldduck/Documents/Projects/SelfProject/react-scrolly/packages/core/src/utils/getIntersectionObserver.ts","/Users/garfieldduck/Documents/Projects/SelfProject/react-scrolly/packages/core/src/hooks/common/useIntersectionObservable.ts","/Users/garfieldduck/Documents/Projects/SelfProject/react-scrolly/packages/core/src/hooks/common/useSubscription.ts","/Users/garfieldduck/Documents/Projects/SelfProject/react-scrolly/packages/core/src/hooks/common/useSectionPosition.ts","/Users/garfieldduck/Documents/Projects/SelfProject/react-scrolly/packages/core/src/hooks/common/usePageScroll.ts","/Users/garfieldduck/Documents/Projects/SelfProject/react-scrolly/packages/core/src/hooks/section/useScrolledRatio.ts","/Users/garfieldduck/Documents/Projects/SelfProject/react-scrolly/packages/core/src/hooks/section/useSection.ts","/Users/garfieldduck/Documents/Projects/SelfProject/react-scrolly/packages/core/src/components/Section.tsx","/Users/garfieldduck/Documents/Projects/SelfProject/react-scrolly/packages/core/src/utils/getStickyPosition.ts","/Users/garfieldduck/Documents/Projects/SelfProject/react-scrolly/packages/core/src/index.ts"],"names":["CenterBox","styledComponents","div","_templateObject","mq","greaterThan","_templateObject2","defaultColors","background","primary","_ref","_ref$boldColor","boldColor","blue","gray","DemoWrapper","styled_media_query__WEBPACK_IMPORTED_MODULE_0__","__webpack_require__","generateMedia","desktop","large","tablet","mobile","d","__webpack_exports__","sectionStyle","text","white","red","orange","yellow","green","purple","margin","height","color","border","concat","padding","marginTop","borderRadius","PageContext","createContext","getScrollPosition","scrollTop","window","pageYOffset","document","documentElement","windowHeight","innerHeight","clientHeight","scrollBottom","useActiveSectionTracker","visibleSections","useRef","sectionScrollRatios","activeSectionId","activeSectionSubjectRef","Subject","activeSectionObservableRef","current","asObservable","updateScrollRatio","useCallback","trackingId","scrolledRatio","activeId","next","id","ratio","updateActiveSection","trackedSects","closest","Object","keys","reduce","accum","idx","sectionTop","distance","addActiveSection","removeActiveSection","activeSectionObs$","PageProvider","children","_ref$resizeThrottleTi","resizeThrottleTime","_useActiveSectionTrac","scrollSubjectRef","scrollObserverRef","pipe","merge","fromEvent","debounceTime","animationFrameScheduler","map","pairwise","_ref2","_ref3","slicedToArray","previousScroll","currentScroll","scrollOffset","objectSpread","resizeObserverRef","Provider","context","scrollObs$","resizeObs$","useEffect","initialScroll","complete","react_default","a","createElement","value","DEFAULT_THRESHOLD","DEFAULT_MARGIN","top","right","bottom","left","getIntersectionObserver","callback","arguments","length","undefined","threshold","rootMargin","_ref$threshold","_ref$rootMargin","IntersectionObserver","root","useIntersectionObservable","sectionRef","intersectionConfig","intersectionObserverRef","intersectSubjectRef","intersectObservableRef","recordIntersection","entries","entry","isIntersecting","boundingClientRect","intersecting","sectionBoundingRect","observe","disconnect","useSubscription","subscription","subscriptionRef","unSubscribe","unsubscribe","setSubscription","subs","useSectionPosition","intersectObsr$","useContext","_useState","useState","boundingRect","width","_useState2","sectionPosition","setSectionPosition","combinedResizeObsRef","switchMap","intersectInfo","of","currentSect","getBoundingClientRect","filter","rect","updateSectionPosition","subscribe","usePageScroll","setIntersecting","_useState3","_useState4","scrollInfo","setScrollInfo","setPageSubscpt","isIntersectingObs","mountScrollObsRef","zip","_ref4","scrollPos","take","windowScrollObsRef","pageScrollObsrRef","_ref5","useScrolledRatio","_useSectionPosition","_usePageScroll","preIntersecting","curInter","preInter","useMemo","useSection","Section","className","style","restProps","objectWithoutProperties","sectionInfo","assign","ref","STICKY_POS","absTop","position","fixed","absBottom","getStickyPosition","section","sectionBottom","stickyHeight","PageProvider_PageProvider","Section_Section"],"mappings":"0lCAIO,IAAMA,EAAYC,IAAiBC,IAApBC,IAQlBC,IAAGC,YAAY,SAAfD,CARkBE,KAaJC,IAAcC,WAInBD,IAAcE,QAQd,SAAAC,GAAA,IAAAC,EAAAD,EAAGE,UAAH,gBAAAD,EAAeJ,IAAcM,KAA7BF,GAMAJ,IAAcO,0pBCjCpB,IAAMC,8EAAcd,EAAiBC,IAApBC,0RCFxB,IAAAa,EAAAC,EAAA,mEAEMb,EAAKc,YAAc,CACvBC,QAAS,OACTC,MAAO,OACPC,OAAQ,SACRC,OAAQ,SAGKlB,uQCTfa,EAAAM,EAAAC,EAAA,sBAAAjB,IAAAU,EAAAM,EAAAC,EAAA,sBAAAC,IAAA,IAEalB,EAAgB,CAC3BE,QAHU,UAIVD,WAAY,UACZkB,KAAM,UACNZ,KAAM,UACND,KAAM,UACNc,MAAO,UACPC,IATU,UAUVC,OAAQ,UACRC,OAAQ,UACRC,MAAO,UACPC,OAAQ,oNAGH,IAAMP,EAAe,CAC1BQ,OAAQ,OACRC,OAAQ,OACRC,MAAO5B,EAAcM,KACrBuB,OAAM,aAAAC,OAAe9B,EAAcO,MACnCwB,QAAS,OACTC,UAAW,OACXC,aAAc,wqECQT,IAAMC,EAAcC,wBAA2C,MC3B/D,SAASC,IACd,IAAMC,EAAYC,OAAOC,aAAeC,SAASC,gBAAgBJ,UAC3DK,EAAeJ,OAAOK,aAAeH,SAASC,gBAAgBG,aAGpE,MAAO,CACLP,YACAQ,aAJmBR,EAAYK,EAK/BA,gBCKG,SAASI,IASd,IAAMC,EAAkBC,iBAAO,IAGzBC,EAAsBD,iBAAO,IAG7BE,EAAkBF,iBAAkB,MAGpCG,EAA0BH,iBAAO,IAAII,KACrCC,EAA6BL,iBAAOG,EAAwBG,QAAQC,gBAKpEC,EAAoBC,sBACxB,SAACC,EAAoBC,GACnB,IAAMC,EAAWV,EAAgBI,QAC7BM,GAAYA,IAAaF,GAE3BP,EAAwBG,QAAQO,KAAK,CACnCC,GAAIJ,EACJK,MAAOJ,IAKXV,EAAoBK,QAAQI,GAAcC,GAE5C,IAOIK,EAAsBP,sBAC1B,SAACZ,GACC,IAAMoB,EAAelB,EAAgBO,QAG/BY,EAA2BC,OAAOC,KAAKH,GAAcI,OACzD,SAACC,EAAwBC,GACvB,IAAMC,EAAaP,EAAaM,GAC1BE,EAAW5B,EAAe2B,EAEhC,OAAKF,GAASG,EAAWH,EAAMG,SACtB,CAAEF,MAAKE,YAETH,GAET,MAGGJ,EAMMhB,EAAgBI,UAAYY,EAAQK,MAC7CrB,EAAgBI,QAAUY,EAAQK,IAGlCpB,EAAwBG,QAAQO,KAAK,CACnCC,GAAII,EAAQK,IACZR,MAAOd,EAAoBK,QAAQY,EAAQK,SAV7CrB,EAAgBI,QAAU,KAG1BH,EAAwBG,QAAQO,KAAK,QAWzC,IA0BF,MAAO,CACLa,iBArBuBjB,sBACvB,SAACC,EAAoBc,EAAoB3B,GACvCE,EAAgBO,QAAQI,GAAcc,EAEtCR,EAAoBnB,IAEtB,IAgBA8B,oBAV0BlB,sBAC1B,SAACC,EAAoBb,UACZE,EAAgBO,QAAQI,GAC/BM,EAAoBnB,IAEtB,IAMAW,oBACAoB,kBAAmBvB,EAA2BC,0rCCvF3C,IAAMuB,EAA6C,SAAA1E,GAGpD,IAFJ2E,EAEI3E,EAFJ2E,SAEIC,EAAA5E,EADJ6E,0BACI,IAAAD,EADiB,IACjBA,EAAAE,EAMAnC,IAJFU,EAFEyB,EAEFzB,kBACAkB,EAHEO,EAGFP,iBACAC,EAJEM,EAIFN,oBACAC,EALEK,EAKFL,kBAOIM,EAAmBlC,iBAAO,IAAII,KAI9B+B,EAAoBnC,iBACxBkC,EAAiB5B,QAAQC,eAAe6B,KACtCC,YACEC,YAAUhD,OAAQ,UACf8C,KAECG,YAAa,EAAGC,KAChBC,YAAI,kBAAMrD,MAGVsD,cACAD,YAAI,SAAAE,GAAqD,IAAAC,EAAAzB,OAAA0B,EAAA,EAAA1B,CAAAwB,EAAA,GAAnDG,EAAmDF,EAAA,GAAnCG,EAAmCH,EAAA,GAIjDI,EAAeD,EAAc1D,UAAYyD,EAAezD,UAE9D,OAAO8B,OAAA8B,EAAA,EAAA9B,CAAA,GACF4B,EADL,CAEEC,uBAWRE,EAAoBlD,iBACxBsC,YAAUhD,OAAQ,UACjB8C,KACCG,YAAaP,KAITmB,EAAajE,EAAbiE,SACFC,EAAgC,CACpC1B,mBACAC,sBACAnB,oBACAoB,oBACAyB,WAAYlB,EAAkB7B,QAC9BgD,WAAYJ,EAAkB5C,SAqBhC,OAlBAiD,oBACE,WACE,IAAMC,EAAarC,OAAA8B,EAAA,EAAA9B,CAAA,GACd/B,IADc,CAEjB4D,aAAc,IAMhB,OAFAd,EAAiB5B,QAAQO,KAAK2C,GAEvB,WAELtB,EAAiB5B,QAAQmD,aAG7B,IAIAC,EAAAC,EAAAC,cAACT,EAAD,CACEU,MAAOT,GAENtB,ggCCxGP,IAAMgC,EAAoB,EACpBC,EAAiB,CACrBC,IAAK,EACLC,MAAO,EACPC,OAAQ,EACRC,KAAM,GAGD,SAASC,EACdC,GAQA,IAAAlH,EAAAmH,UAAAC,OAAA,QAAAC,IAAAF,UAAA,GAAAA,UAAA,GAJgC,CAC9BG,UAAWX,EACXY,WAAYX,GAEdY,EAAAxH,EANEsH,iBAMF,IAAAE,EANcb,EAMda,EAAAC,EAAAzH,EALEuH,kBAKF,IAAAE,EALeb,EAKfa,EACQZ,EAA6BU,EAA7BV,IAAKC,EAAwBS,EAAxBT,MAAOC,EAAiBQ,EAAjBR,OAAQC,EAASO,EAATP,KAE5B,OAAO,IAAIU,qBAAqBR,EAAU,CACxCI,YAGAK,KAAM,KAMNJ,WAAU,GAAA5F,OAAKkF,EAAL,OAAAlF,OAAcmF,EAAd,OAAAnF,OAAyBoF,EAAzB,OAAApF,OAAqCqF,EAArC,QC9BP,SAASY,EAEdC,EAGAtE,EAGAuE,GAKA,IAAMC,EAA0BlF,iBAAoC,MAG9DmF,EAAsBnF,iBAAO,IAAII,KACjCgF,EAAyBpF,iBAAOmF,EAAoB7E,QAAQC,gBAG5D8E,EAAqB5E,sBACzB,SAAC6E,GAAyC,IACjCC,EADiCpE,OAAA0B,EAAA,EAAA1B,CACxBmE,EADwB,MAEhCE,EAAuCD,EAAvCC,eAAgBC,EAAuBF,EAAvBE,mBAClBC,EAAiC,CACrCF,iBACA9E,aACAiF,oBAAqBF,GAGvBN,EAAoB7E,QAAQO,KAAK6E,IAEnC,IAwBF,OArBAnC,oBACE,WAUE,OARA2B,EAAwB5E,QAAU8D,EAChCiB,EACAJ,GAGFC,EAAwB5E,QAAQsF,QAAQZ,EAAW1E,SAG5C,WACD4E,EAAwB5E,UAC1B4E,EAAwB5E,QAAQuF,aAChCV,EAAoB7E,QAAQmD,cAIlC,IAGK2B,EAAuB9E,o8BC7DzB,SAASwF,EACdC,GAEA,IAAMC,EAAkBhG,iBAA4C+F,GAG9DE,EAAcxF,sBAClB,WACMuF,EAAgB1F,SAClB0F,EAAgB1F,QAAQ4F,eAG5B,IAIIC,EAAkB1F,sBACtB,SAAC2F,GACCH,IACAD,EAAgB1F,QAAU8F,GAE5B,IAaF,OAVA7C,oBACE,WAEE,OAAO,WACL0C,MAGJ,IAGK,CACLE,kBACAF,cACAF,aAAcC,EAAgB1F,SC3B3B,SAAS+F,EAEdrB,EACAsB,GAGA,IACQhD,EADQiD,qBAAwCrH,GAChDoE,WAHSkD,EAK6BC,mBAA0B,CACtEjF,WAAY,EACZkF,aAAc,CACZ1C,IAAK,EACLC,MAAO,EACPE,KAAM,EACND,OAAQ,EACRvF,OAAQ,EACRgI,MAAO,KAbMC,EAAAzF,OAAA0B,EAAA,EAAA1B,CAAAqF,EAAA,GAKVK,EALUD,EAAA,GAKOE,EALPF,EAAA,GAkBTT,EAAoBL,EAAgB,MAApCK,gBAGFY,EAAuB/G,iBAAOsG,EAAelE,KACjD4E,YAAU,SAACC,GAAkB,IACnBzB,EAAwCyB,EAAxCzB,eAAgBG,EAAwBsB,EAAxBtB,oBACxB,OAAOH,EAGH0B,YAAGvB,GAEFvD,KACCC,YAAMiB,EAAWlB,KACfK,YAAI,WACF,IAAM0E,EAAcnC,EAAW1E,QAC/B,GAAI6G,EAEF,OADaA,EAAYC,6BASjCF,iBAAG1C,KAET6C,YAAO,SAAAC,GAAI,MAAoB,qBAATA,MAMlBC,EAAwB9G,sBAC5B,SAACgF,GACC,IAAMpG,EAAYC,OAAOC,aAAeC,SAASC,gBAAgBJ,UACzD2E,EAAQyB,EAARzB,IAER8C,EAAmB,CACjBtF,WAAYwC,EAAM3E,EAClBqH,aAAcjB,KAGlB,IAoBF,OAjBAlC,oBACE,WAEMyB,EAAW1E,SACbiH,EAAsBvC,EAAW1E,QAAQ8G,yBAI3CjB,EAAgBY,EAAqBzG,QAAQkH,UAAU,CACrD3G,KAAM,SAAC8E,GACL4B,EAAsB5B,QAI5B,IAGKkB,2qCC7FF,SAASY,EACdnB,GAEA,IACQjD,EADQkD,qBAAwCrH,GAChDmE,WAFRmD,EAIwCC,oBAAkB,GAJ1DG,EAAAzF,OAAA0B,EAAA,EAAA1B,CAAAqF,EAAA,GAIOd,EAJPkB,EAAA,GAIqBc,EAJrBd,EAAA,GAAAe,EAMoClB,mBAAyB,CAC3DpH,UAAW,EACXQ,aAAc,EACdH,aAAc,EACdsD,aAAc,IAVhB4E,EAAAzG,OAAA0B,EAAA,EAAA1B,CAAAwG,EAAA,GAMOE,EANPD,EAAA,GAMmBE,EANnBF,EAAA,GAcyBG,EAAmBjC,EAAgB,MAApDK,gBACF6B,EAAoBhI,iBAAOsG,EAAelE,KAC9CK,YAAI,SAAAE,GAAA,OAAAA,EAAG6C,mBAOHyC,EAAoBjI,iBACxBkI,YACE7E,EACA2E,EAAkB1H,SAClB8B,KACAK,YAAI,SAAAG,GAAA,IAAAuF,EAAAhH,OAAA0B,EAAA,EAAA1B,CAAAyB,EAAA,GAAEwF,EAAFD,EAAA,SAGE,CACJ3C,eAJE2C,EAAA,GAKFC,UAAUjH,OAAA8B,EAAA,EAAA9B,CAAA,GACLiH,EADI,CAEPpF,aAAc,OAGlBqF,YAAK,KAOHC,EAAqBtI,iBACzBgI,EAAkB1H,QAAQ8B,KACxB4E,YAAU,SAACxB,GAET,OAAOA,EACHnC,EAAWjB,KACXK,YAAI,SAAC2F,GAAD,MAAgC,CAClC5C,iBACA4C,gBAIFlB,YAAG,CACH1B,iBACA4C,UAAW,WAMfG,EAAoBvI,iBACxBiI,EAAkB3H,QAAQ8B,KACxBC,YAAMiG,EAAmBhI,WA8B7B,OA1BAiD,oBACE,WAEEwE,EAAeQ,EAAkBjI,QAAQkH,UAAU,CAEjD3G,KAAM,SAAA2H,GAAmC,IAAhChD,EAAgCgD,EAAhChD,eAAgB4C,EAAgBI,EAAhBJ,UACvB,GAAI5C,GAAkB4C,EAAW,KACvB/I,EAAwD+I,EAAxD/I,UAAWQ,EAA6CuI,EAA7CvI,aAAcH,EAA+B0I,EAA/B1I,aAAcsD,EAAiBoF,EAAjBpF,aAG/C8E,EAAc,CACZzI,YACAQ,eACAH,eACAsD,iBAKJ0E,EAAgBlC,QAItB,IAGK,CACLqC,aACArC,eAAgBE,GChGb,SAAS+C,EAEdzD,EAEAsB,EASA5F,GAEA,IADavD,EACGoJ,qBAAwCrH,GAChDwC,EAFKvE,EAELuE,iBAAkBC,EAFbxE,EAEawE,oBAAqBnB,EAFlCrD,EAEkCqD,kBAFlCkI,EAIwBrC,EAAmBrB,EAAYsB,GAA5D9E,EAJKkH,EAILlH,WAAYkF,EAJPgC,EAIOhC,aAJPiC,EAM0BlB,EAAcnB,GAA7Cd,EANKmD,EAMLnD,eAAgBqC,EANXc,EAMWd,WAElBe,EAAkB5I,kBAAO,GAG/BuD,oBACE,WACE,IAAMsF,EAAWrD,EACXsD,EAAWF,EAAgBtI,QAE7BI,KACGoI,GAAYD,EAEfnH,EAAiBhB,EAAYc,EAAYqG,EAAWhI,cAC3CiJ,IAAaD,GAEtBlH,EAAoBjB,EAAYmH,EAAWhI,eAI/C+I,EAAgBtI,QAAUuI,GAE5B,CAACnI,EAAY8E,EAAgBhE,EAAYqG,IAG3C,IAAMlH,EAAgBoI,kBACpB,WAAM,IACIlJ,EAAiBgI,EAAjBhI,aACAlB,EAAW+H,EAAX/H,OAGJoC,GADalB,EAAe2B,GACT7C,EAevB,OAbIoC,GAAS,EACXA,EAAQ,EACCA,GAAS,IAClBA,EAAQ,GAMNL,GACFF,EAAkBE,EAAYK,GAGzBA,GAET,CAACL,EAAYc,EAAYkF,EAAcmB,IAGzC,MAAO,CACLrC,iBACA7E,gBACAa,aACAqG,aACAnB,gBC9FG,SAASsC,EAEdhE,EASAtE,GAGA,OAAO+H,EAAiBzD,EADDD,EAA0BC,EAAYtE,GACTA,qpCCK/C,IAAMuI,EAAU,SAAA9L,GAMH,IALlB+L,EAKkB/L,EALlB+L,UACAC,EAIkBhM,EAJlBgM,MACArH,EAGkB3E,EAHlB2E,SACApB,EAEkBvD,EAFlBuD,WACG0I,EACejI,OAAAkI,EAAA,EAAAlI,CAAAhE,EAAA,+CACZ6H,EAAahF,iBAAuB,MACpCsJ,EAAcN,EAAWhE,EAAYtE,GAE3C,OACEgD,EAAAC,EAAAC,cAAA,MAAAzC,OAAAoI,OAAA,CACEC,IAAKxE,EACLkE,UAAWA,EACXC,MAAOA,GACHC,GAEHtH,EAASwH,gMCzChB,IAAMG,EAIF,CACFC,OAAQ,CACNC,SAAU,WACV3F,IAAK,EACL2C,MAAO,QAETiD,MAAO,CACLD,SAAU,QACV3F,IAAK,GAEP6F,UAAW,CACTF,SAAU,WACVzF,OAAQ,EACRyC,MAAO,SAOJ,SAASmD,EACdC,GACqB,IAEnBlC,EAGEkC,EAHFlC,WACArG,EAEEuI,EAFFvI,WACAkF,EACEqD,EADFrD,aAEMrH,EAA4BwI,EAA5BxI,UAAWQ,EAAiBgI,EAAjBhI,aACbmK,EAAgBxI,EAAakF,EAAa/H,OAC1CsL,EAAe,CACnBtL,OAAM,GAAAG,OAAKiL,EAAQlC,WAAWnI,aAAxB,OAGR,OAAIL,EAAYmC,EAEPL,OAAA8B,EAAA,EAAA9B,CAAA,GAAK8I,EAAiBR,EAAWC,QAGrCrK,GAAamC,GAAgBwI,EAAgBnK,EAEzCsB,OAAA8B,EAAA,EAAA9B,CAAA,GACF8I,EACAR,EAAWG,MAFhB,CAGEzF,KAAMuC,EAAavC,KACnBwC,MAAOD,EAAaC,QAKjBxF,OAAA8B,EAAA,EAAA9B,CAAA,GAAK8I,EAAiBR,EAAWI,oNCxD1CnM,EAAAM,EAAAC,EAAA,sBAAAiM,IAAAxM,EAAAM,EAAAC,EAAA,sBAAAkM,IAAAzM,EAAAM,EAAAC,EAAA,sBAAAiB,IAAAxB,EAAAM,EAAAC,EAAA,sBAAAmG,IAAA1G,EAAAM,EAAAC,EAAA,sBAAA6L,IAAApM,EAAAM,EAAAC,EAAA,sBAAA8G,IAAArH,EAAAM,EAAAC,EAAA,sBAAAwK,IAAA/K,EAAAM,EAAAC,EAAA,sBAAA+K,IAAAtL,EAAAM,EAAAC,EAAA,sBAAA6H","file":"static/js/docs-src-pinning-sections-sticky-plot~docs-src-pinning-sections-sticky-scene~docs-src-revealing-anim~a7ac5c86.cb554407.js","sourcesContent":["import styledComponents from 'styled-components';\nimport mq from '../config/media-queries';\nimport { defaultColors } from '../config/theme';\n\nexport const CenterBox = styledComponents.div`\n  position: absolute;\n  top: 50%;\n  left: 50%;\n  transform: translate(-50%, -50%);\n  font-size: 1.1rem;\n  list-style: none;\n\n  ${mq.greaterThan('mobile')`\n    font-size: 1.5rem;\n  `}\n\n  h4 {\n    background: ${defaultColors.background};\n    display: inline-block;\n    padding: 0.1rem 0.5rem;\n    border-radius: 6px;\n    color: ${defaultColors.primary};\n    margin-left: -0.5rem;\n  }\n\n  b {\n    padding: 0.05rem 0.25rem;\n    border-radius: 3px;\n    background: rgba(255, 255, 255, 0.85);\n    color: ${({ boldColor = defaultColors.blue }) => boldColor};\n  }\n\n  li:before {\n    content: \"•\";\n    padding-right: 1rem;\n    color: ${defaultColors.gray};\n  }\n`;\n","import styledComponents from 'styled-components';\n\nexport const DemoWrapper = styledComponents.div`\n  padding: 2rem 1rem;\n  margin: 1.8rem 0;\n  background: #ffffff;\n  border-radius: 5px;\n  box-shadow: 0 12px 22px 0 rgba(0,0,0,.06), 0 6px 14px 0 rgba(0,0,0,.03);\n`;\n","import { generateMedia } from 'styled-media-query';\n\nconst mq = generateMedia({\n  desktop: '78em',\n  large: '70em',\n  tablet: '60.5em',\n  mobile: '46em',\n});\n\nexport default mq;\n","const RED = '#ef3e36';\n\nexport const defaultColors = {\n  primary: RED,\n  background: '#f3f3f3',\n  text: '#282c34',\n  gray: '#8a96b1',\n  blue: '#1b76f1',\n  white: '#ffffff',\n  red: RED,\n  orange: '#ff8e2b',\n  yellow: '#ffd60a',\n  green: '#24da74',\n  purple: '#8755d6',\n}\n\nexport const sectionStyle = {\n  margin: 'auto',\n  height: '30vh',\n  color: defaultColors.blue,\n  border: `3px solid ${defaultColors.gray}`,\n  padding: '1rem',\n  marginTop: '-3px',\n  borderRadius: '3px',\n};\n","import { createContext } from 'react';\nimport { Observable } from 'rxjs';\n\nexport type sectionID = string | null;\n\ninterface ScrollPosition {\n  scrollTop: number;\n  scrollBottom: number;\n  windowHeight: number;\n}\n\nexport interface ActiveSectionInfo {\n  /** `trackingId` of the active section (section closest to the bottom of the viewport) */\n  id: sectionID;\n\n  /** Ratio of the active section being scrolled  */\n  ratio: number | null;\n}\n\nexport interface ActiveSectionTracker {\n  addActiveSection: (trackingId: string,  sectionTop: number, scrollBottom: number) => void;\n  removeActiveSection: (trackingId: string, scrollBottom: number) => void;\n  updateScrollRatio: (trackingId: string, scrolledRatio: number) => void;\n  activeSectionObs$: Observable<ActiveSectionInfo | null>;\n}\n\nexport interface PageContextInterface extends ActiveSectionTracker {\n  scrollObs$: Observable<ScrollPosition>;\n  resizeObs$: Observable<Event>;\n}\n\nexport const PageContext = createContext<PageContextInterface | null>(null);\n","/**\n * Returns the current window `scrollTop`, `windowHeight` (height of the window),\n * and the `scrollBottom` (`scrollTop` + `windowHeight`)\n */\nexport function getScrollPosition() {\n  const scrollTop = window.pageYOffset || document.documentElement.scrollTop;\n  const windowHeight = window.innerHeight || document.documentElement.clientHeight;\n  const scrollBottom = scrollTop + windowHeight;\n\n  return {\n    scrollTop,\n    scrollBottom,\n    windowHeight,\n  };\n}\n","import {\n  useRef,\n  useCallback,\n} from 'react';\nimport { Subject } from 'rxjs';\n\nimport { ActiveSectionInfo, ActiveSectionTracker, sectionID } from '../../context/PageContext';\n\ntype SectionDistance = {\n  idx: string,\n  distance: number,\n} | null;\n\n/**\n * Manage the current active section tracking ID\n * by selecting the section closest to the scroll bottom\n */\nexport function useActiveSectionTracker(): ActiveSectionTracker {\n  /**\n   * keep track of the all the sections appeared in the viewport,\n   * - Key: `trackingId`\n   * - Value: `sectionTop`.\n   * @example {\n   *  'section-2': 1000,\n   * }\n   */\n  const visibleSections = useRef({});\n\n  /** keep track of the scrollRatios updated by `updateScrollRatio` */\n  const sectionScrollRatios = useRef({});\n\n  /** keep track of the `trackingId` of the section closet to the bottom of the viewport */\n  const activeSectionId = useRef<sectionID>(null);\n\n  // make a Subject to take all the changes and transform it as a RX Observable\n  const activeSectionSubjectRef = useRef(new Subject<ActiveSectionInfo | null>());\n  const activeSectionObservableRef = useRef(activeSectionSubjectRef.current.asObservable());\n\n  /**\n   * Let Section set the scrolled ratio if it is active\n   */\n  const updateScrollRatio = useCallback(\n    (trackingId: string, scrolledRatio: number) => {\n      const activeId = activeSectionId.current;\n      if (activeId && activeId === trackingId) {\n        // notify all sections subscribing to ActiveSectionInfo\n        activeSectionSubjectRef.current.next({\n          id: trackingId,\n          ratio: scrolledRatio,\n        });\n      }\n\n      // update the scroll ratios of the sections\n      sectionScrollRatios.current[trackingId] = scrolledRatio;\n    },\n    [],\n  );\n\n  /**\n   * Update the current active section by selecting the section\n   * closest to the bottom of the viewport\n   */\n  const updateActiveSection = useCallback(\n    (scrollBottom: number) => {\n      const trackedSects = visibleSections.current;\n\n      // find the item closest to the bottom of the viewport\n      const closest: SectionDistance = Object.keys(trackedSects).reduce(\n        (accum: SectionDistance, idx) => {\n          const sectionTop = trackedSects[idx];\n          const distance = scrollBottom - sectionTop;\n\n          if (!accum || distance < accum.distance) {\n            return { idx, distance };\n          }\n          return accum;\n        },\n        null,\n      );\n\n      if (!closest) {\n        // there is no section in the viewport\n        activeSectionId.current = null;\n\n        // notify all sections subscribing to ActiveSectionInfo\n        activeSectionSubjectRef.current.next(null);\n      } else if (activeSectionId.current !== closest.idx) {\n        activeSectionId.current = closest.idx;\n\n        // notify there is a new section being added\n        activeSectionSubjectRef.current.next({\n          id: closest.idx,\n          ratio: sectionScrollRatios.current[closest.idx],\n        });\n      }\n    },\n    [],\n  );\n\n  /**\n   * Add a section that is in the viewport\n   */\n  const addActiveSection = useCallback(\n    (trackingId: string, sectionTop: number, scrollBottom: number) => {\n      visibleSections.current[trackingId] = sectionTop;\n\n      updateActiveSection(scrollBottom);\n    },\n    [],\n  );\n\n  /**\n   * Remove a section from the active sections\n   */\n  const removeActiveSection = useCallback(\n    (trackingId: string, scrollBottom: number) => {\n      delete visibleSections.current[trackingId];\n      updateActiveSection(scrollBottom);\n    },\n    [],\n  );\n\n  return {\n    addActiveSection,\n    removeActiveSection,\n    updateScrollRatio,\n    activeSectionObs$: activeSectionObservableRef.current,\n  };\n}\n","import React, { FunctionComponent, useRef, useEffect } from 'react';\nimport {\n  Observable,\n  Subject,\n  fromEvent,\n  animationFrameScheduler,\n} from 'rxjs';\nimport { debounceTime, map, pairwise, merge } from 'rxjs/operators';\n\nimport { PageContext, PageContextInterface } from '../context/PageContext';\nimport { getScrollPosition } from '../utils/getScrollPosition';\nimport { useActiveSectionTracker } from '../hooks/page/useActiveSectionTracker';\n\nexport interface ScrollPosition {\n  /** The pageYOffset of the window obtained in <PageProvider>  */\n  scrollTop: number;\n\n  /** The pageYOffset + height of the window obtained in <PageProvider> */\n  scrollBottom: number;\n\n  /** The height of the window obtained in <PageProvider> */\n  windowHeight: number;\n\n  /**\n   * The difference between the current scrolltop and previous scrolltop obtained in <PageProvider>.\n   * Positive: if the user scroll down the page.\n   */\n  scrollOffset: number;\n}\n\nexport interface PageProps {\n  children: React.ReactNode;\n\n  /**\n   * Allows the window resizing event to go through again after the `resizeThrottleTime`\n   */\n  resizeThrottleTime: number;\n}\n\nexport const PageProvider: FunctionComponent<PageProps> = ({\n  children,\n  resizeThrottleTime = 300,\n}) => {\n  const {\n    updateScrollRatio,\n    addActiveSection,\n    removeActiveSection,\n    activeSectionObs$,\n  } = useActiveSectionTracker();\n\n  /**\n   * Subject to be combined with `scrollSubjectRef`\n   * in order to listen to the initial window scroll position on mounted\n   */\n  const scrollSubjectRef = useRef(new Subject<ScrollPosition>());\n  /**\n   * Observer to listen to page scroll\n   */\n  const scrollObserverRef = useRef<Observable<ScrollPosition>>(\n    scrollSubjectRef.current.asObservable().pipe(\n      merge(\n        fromEvent(window, 'scroll')\n          .pipe(\n            // throttled by the animation frame\n            debounceTime(0, animationFrameScheduler),\n            map(() => getScrollPosition()),\n            // use pairwise to group pairs of consecutive emissions\n            // so that we can calculate `scrollOffset`\n            pairwise(),\n            map(([previousScroll, currentScroll]): ScrollPosition => {\n              // amount of pixels scrolled by\n              // - postive: scroll down\n              // - negative: scroll up\n              const scrollOffset = currentScroll.scrollTop - previousScroll.scrollTop;\n\n              return {\n                ...currentScroll,\n                scrollOffset,\n              };\n            }),\n        ),\n      )\n    )\n  );\n\n  /**\n   * Observer to listen to window resize\n   */\n  const resizeObserverRef = useRef(\n    fromEvent(window, 'resize')\n    .pipe(\n      debounceTime(resizeThrottleTime),\n    ),\n  );\n\n  const { Provider } = PageContext;\n  const context: PageContextInterface = {\n    addActiveSection,\n    removeActiveSection,\n    updateScrollRatio,\n    activeSectionObs$,\n    scrollObs$: scrollObserverRef.current,\n    resizeObs$: resizeObserverRef.current,\n  };\n\n  useEffect(\n    () => {\n      const initialScroll = {\n        ...getScrollPosition(),\n        scrollOffset: 0,\n      };\n\n      // send the initial window scrolling position on mounted\n      scrollSubjectRef.current.next(initialScroll);\n\n      return () => {\n        // complete the scrolling subject\n        scrollSubjectRef.current.complete();\n      };\n    },\n    [],\n  );\n\n  return (\n    <Provider\n      value={context}\n    >\n      {children}\n    </Provider>\n  );\n};\n","import 'intersection-observer';\n\nexport interface Margin {\n  top: number;\n  right: number;\n  bottom: number;\n  left: number;\n}\n\nexport interface IntersectionObserverConfig {\n  /**\n   * Threshold at which to trigger callback.\n   * See: https://developers.google.com/web/updates/2016/04/intersectionobserver\n   */\n  threshold: number[] | 0 | 1;\n\n  /**\n   * Margins for the root (document’s viewport),\n   * which allows you to  grow or shrink the area used for intersections\n   */\n  rootMargin: Margin;\n}\n\nconst DEFAULT_THRESHOLD = 0;\nconst DEFAULT_MARGIN = {\n  top: 0,\n  right: 0,\n  bottom: 0,\n  left: 0,\n};\n\nexport function getIntersectionObserver(\n  callback: (entries: IntersectionObserverEntry[]) => void,\n  {\n    threshold = DEFAULT_THRESHOLD,\n    rootMargin = DEFAULT_MARGIN,\n  }: IntersectionObserverConfig = {\n    threshold: DEFAULT_THRESHOLD,\n    rootMargin: DEFAULT_MARGIN,\n  }\n) {\n  const { top, right, bottom, left } = rootMargin;\n\n  return new IntersectionObserver(callback, {\n    threshold,\n\n    /**  Observe changes in visibility of the section relative to the document's viewport */\n    root: null,\n\n    /**\n     * Watch only the changes in the intersection between the section and the viewport,\n     * without any added or substracted space\n     */\n    rootMargin: `${top}px ${right}px ${bottom}px ${left}px`,\n  });\n}\n","import React, {\n  useEffect,\n  useRef,\n  useCallback,\n} from 'react';\nimport { Observable, Subject } from 'rxjs';\n\nimport {\n  getIntersectionObserver,\n  IntersectionObserverConfig,\n} from '../../utils/getIntersectionObserver';\n\nexport interface IntersectionInfo {\n  /** From IntersectionObserver: whether the `<Section>` is intersecting the root */\n  isIntersecting: boolean;\n\n  /** Tracking ID of the section  */\n  trackingId?: string;\n\n  /** The bounding rectangle of `<Section>` */\n  sectionBoundingRect: ClientRect;\n}\n\nexport function useIntersectionObservable(\n  /** Ref which is binded to the section */\n  sectionRef: React.RefObject<HTMLElement>,\n\n  /** Provide the ID if the section is going to be tracked on the page */\n  trackingId: IntersectionInfo['trackingId'],\n\n  /** Margin and threshold configurations for IntersectionObserver */\n  intersectionConfig?: IntersectionObserverConfig,\n): Observable<IntersectionInfo> {\n  /**\n   * Stores references to the observer listening to section intersection with the viewport\n   */\n  const intersectionObserverRef = useRef<IntersectionObserver | null>(null);\n\n  // transform the intersectionObserver as a RX Observable\n  const intersectSubjectRef = useRef(new Subject<IntersectionInfo>());\n  const intersectObservableRef = useRef(intersectSubjectRef.current.asObservable());\n\n  /** Use browser's IntersectionObserver to record whether the section is inside the viewport */\n  const recordIntersection = useCallback(\n    (entries: IntersectionObserverEntry[]) => {\n      const [entry] = entries;\n      const { isIntersecting, boundingClientRect } = entry;\n      const intersecting: IntersectionInfo = {\n        isIntersecting,\n        trackingId,\n        sectionBoundingRect: boundingClientRect,\n      };\n\n      intersectSubjectRef.current.next(intersecting);\n    },\n    []\n  );\n\n  useEffect(\n    () => {\n      // start observing whether the section is scrolled into the viewport\n      intersectionObserverRef.current = getIntersectionObserver(\n        recordIntersection,\n        intersectionConfig\n      );\n\n      intersectionObserverRef.current.observe(sectionRef.current!);\n\n      // unsubscribe to the intersection observer on unmounting\n      return () => {\n        if (intersectionObserverRef.current) {\n          intersectionObserverRef.current.disconnect();\n          intersectSubjectRef.current.complete();\n        }\n      };\n    },\n    []\n  );\n\n  return intersectObservableRef.current;\n}\n","import {\n  useEffect,\n  useRef,\n  useCallback,\n} from 'react';\nimport { Subscription } from 'rxjs';\n\nexport interface SubscriptionControl {\n  /** Subscription to a stream */\n  subscription: Subscription | null;\n\n  /** Unsubscribe to the current subscription */\n  unSubscribe: () => void;\n\n  /** Change the subscription */\n  setSubscription: (sub: Subscription) => void;\n}\n\nexport function useSubscription(\n  subscription: SubscriptionControl['subscription'],\n) {\n  const subscriptionRef = useRef<SubscriptionControl['subscription']>(subscription);\n\n  /** Function to unscribe the current subscription */\n  const unSubscribe = useCallback(\n    () => {\n      if (subscriptionRef.current) {\n        subscriptionRef.current.unsubscribe();\n      }\n    },\n    [],\n  );\n\n  /** Function to set the latest subscription */\n  const setSubscription = useCallback(\n    (subs) => {\n      unSubscribe();\n      subscriptionRef.current = subs;\n    },\n    [],\n  );\n\n  useEffect(\n    () => {\n      // unsubscribe the subscription on unmounting\n      return () => {\n        unSubscribe();\n      };\n    },\n    [],\n  );\n\n  return {\n    setSubscription,\n    unSubscribe,\n    subscription: subscriptionRef.current,\n  };\n}\n","import { Observable, of } from 'rxjs';\nimport {\n  map,\n  filter,\n  switchMap,\n  merge,\n } from 'rxjs/operators';\nimport React, {\n  useState,\n  useEffect,\n  useRef,\n  useContext,\n  useCallback,\n} from 'react';\n\nimport { PageContext, PageContextInterface } from '../../context/PageContext';\n\nimport { IntersectionInfo } from './useIntersectionObservable';\nimport { useSubscription } from './useSubscription';\n\nexport interface SectionPosition {\n  /** From IntersectionObserver: the top of the `<Section>` + scrollTop */\n  sectionTop: number;\n\n  /** The bounding rectangle of `<Section>` */\n  boundingRect: ClientRect;\n}\n\nexport function useSectionPosition(\n  /** Ref of the section being tracked */\n  sectionRef: React.RefObject<HTMLElement>,\n  intersectObsr$: Observable<IntersectionInfo>,\n): SectionPosition {\n\n  const context = useContext<PageContextInterface | null>(PageContext);\n  const { resizeObs$ } = context!;\n\n  const [sectionPosition, setSectionPosition] = useState<SectionPosition>({\n    sectionTop: 0,\n    boundingRect: {\n      top: 0,\n      right: 0,\n      left: 0,\n      bottom: 0,\n      height: 1,\n      width: 1,\n    },\n  });\n\n  /** Function to set the subscription to the page resizing  */\n  const { setSubscription } = useSubscription(null);\n\n  /** Observer to the window resizing events */\n  const combinedResizeObsRef = useRef(intersectObsr$.pipe(\n    switchMap((intersectInfo) => {\n      const { isIntersecting, sectionBoundingRect } = intersectInfo;\n      return isIntersecting\n        ? (\n          // return the bounding rect from `intersectObsr$` when it appears in the viewport\n          of(sectionBoundingRect)\n          // merge it with the intersection observer\n          .pipe(\n            merge(resizeObs$.pipe(\n              map(() => {\n                const currentSect = sectionRef.current;\n                if (currentSect) {\n                  const rect = currentSect.getBoundingClientRect();\n                  return rect;\n                }\n                return undefined;\n              }),\n            ))\n          )\n        )\n        // when the section is scrolled out of the viewport\n        : of(undefined);\n    }),\n    filter(rect => typeof rect !== 'undefined'),\n  ));\n\n  /**\n   * Update the absolute position of the section\n   */\n  const updateSectionPosition = useCallback(\n    (boundingClientRect) => {\n      const scrollTop = window.pageYOffset || document.documentElement.scrollTop;\n      const { top } = boundingClientRect;\n\n      setSectionPosition({\n        sectionTop: top + scrollTop,\n        boundingRect: boundingClientRect,\n      });\n    },\n    [],\n  );\n\n  useEffect(\n    () => {\n      // update the dimension of the section when it's mounted\n      if (sectionRef.current) {\n        updateSectionPosition(sectionRef.current.getBoundingClientRect());\n      }\n\n      // set the subscription to the page resizing events and intersection events\n      setSubscription(combinedResizeObsRef.current.subscribe({\n        next: (sectionBoundingRect) => {\n          updateSectionPosition(sectionBoundingRect!);\n        },\n      }));\n    },\n    [],\n  );\n\n  return sectionPosition;\n}\n","import { Observable, of, zip } from 'rxjs';\nimport {\n  map,\n  switchMap,\n  merge,\n  take,\n} from 'rxjs/operators';\nimport {\n  useState,\n  useEffect,\n  useRef,\n  useContext,\n} from 'react';\n\nimport { PageContext, PageContextInterface } from '../../context/PageContext';\nimport { ScrollPosition } from '../../components/PageProvider';\n\nimport { IntersectionInfo } from './useIntersectionObservable';\nimport { useSubscription } from './useSubscription';\n\nexport function usePageScroll(\n  intersectObsr$: Observable<IntersectionInfo>,\n) {\n  const context = useContext<PageContextInterface | null>(PageContext);\n  const { scrollObs$ } = context!;\n\n  const [intersecting, setIntersecting] = useState<boolean>(false);\n\n  const [scrollInfo, setScrollInfo] = useState<ScrollPosition>({\n    scrollTop: 0,\n    scrollBottom: 0,\n    windowHeight: 0,\n    scrollOffset: 0,\n  });\n\n  /** Function to set the subscription to the page scrolling  */\n  const { setSubscription: setPageSubscpt } = useSubscription(null);\n  const isIntersectingObs = useRef(intersectObsr$.pipe(\n    map(({ isIntersecting }) => isIntersecting)\n  ));\n\n  /**\n   * Observer to track the scroll position\n   * emitted when Page is mounted\n   */\n  const mountScrollObsRef = useRef(\n    zip(\n      scrollObs$,\n      isIntersectingObs.current,\n    ).pipe(\n      map(([scrollPos, isIntersecting]): {\n        isIntersecting: boolean,\n        scrollPos: ScrollPosition,\n      } => ({\n        isIntersecting,\n        scrollPos: {\n          ...scrollPos,\n          scrollOffset: 0,\n        },\n      })),\n      take(1),\n    )\n  );\n  /**\n   * Observer to track the scroll position\n   * when real scrolling events are triggered\n   */\n  const windowScrollObsRef = useRef(\n    isIntersectingObs.current.pipe(\n      switchMap((isIntersecting: boolean) => {\n        // use `isIntersecting` to determine whether to take the scrolling info\n        return isIntersecting\n          ? scrollObs$.pipe(\n            map((scrollPos: ScrollPosition) => ({\n              isIntersecting,\n              scrollPos,\n            })),\n          )\n          // when the section is scrolled out of the viewport, update its dimension\n          : of({\n            isIntersecting,\n            scrollPos: null,\n          });\n      })\n    )\n  );\n  /** Observer to track the page scrolling by combining mountScrollObs and windowScrollObs */\n  const pageScrollObsrRef = useRef(\n    mountScrollObsRef.current.pipe(\n      merge(windowScrollObsRef.current),\n    )\n  );\n\n  useEffect(\n    () => {\n      // subscribe to the page scrolling\n      setPageSubscpt(pageScrollObsrRef.current.subscribe({\n        // record the page scrolling\n        next: ({ isIntersecting, scrollPos }) => {\n          if (isIntersecting && scrollPos) {\n            const { scrollTop, scrollBottom, windowHeight, scrollOffset } = scrollPos;\n\n            // updates the ratio of the section being scrolled and the scroll positions\n            setScrollInfo({\n              scrollTop,\n              scrollBottom,\n              windowHeight,\n              scrollOffset,\n            });\n          }\n\n          // update the intersecting state\n          setIntersecting(isIntersecting);\n        },\n      }));\n    },\n    [],\n  );\n\n  return {\n    scrollInfo,\n    isIntersecting: intersecting,\n  };\n}\n","import { Observable } from 'rxjs';\nimport {\n  useRef,\n  useMemo,\n  useEffect,\n  useContext,\n} from 'react';\n\nimport { ScrollPosition } from '../../components/PageProvider';\nimport { PageContext, PageContextInterface } from '../../context/PageContext';\nimport { useSectionPosition, SectionPosition } from '../common/useSectionPosition';\nimport { usePageScroll } from '../common/usePageScroll';\nimport { IntersectionInfo } from '../common/useIntersectionObservable';\n\nexport interface SectionInfo extends SectionPosition {\n  /** Whether the section is intersecting with the viewport */\n  isIntersecting: boolean;\n\n  /** Information related to the window scrolling and the ratio of the section being scrolled */\n  scrollInfo: ScrollPosition;\n\n  /** Ratio of the section being scrolled */\n  scrolledRatio: number;\n}\n\nexport function useScrolledRatio(\n  /** Ref of the section being tracked */\n  sectionRef: React.RefObject<HTMLElement>,\n\n  intersectObsr$: Observable<IntersectionInfo>,\n\n  /**\n   * By setting an unique Section ID, you can know which section the user is currently viewing.\n   * If `trackingId` is not null,\n   * it will trigger the update of the active section infomation managed in `<Page>`.\n   * Please make sure that on the same `scrollTop`,\n   * there is **NO** more than one tracked section (section with `trackingId`).\n   */\n  trackingId?: string,\n): SectionInfo {\n  const context = useContext<PageContextInterface | null>(PageContext);\n  const { addActiveSection, removeActiveSection, updateScrollRatio } = context!;\n\n  const { sectionTop, boundingRect } = useSectionPosition(sectionRef, intersectObsr$);\n\n  const { isIntersecting, scrollInfo } = usePageScroll(intersectObsr$);\n\n  const preIntersecting = useRef(false);\n\n  // update the active section info if `isIntersecting` changes\n  useEffect(\n    () => {\n      const curInter = isIntersecting;\n      const preInter = preIntersecting.current;\n\n      if (trackingId) {\n        if (!preInter && curInter) {\n          // update the section currently being scrolled\n          addActiveSection(trackingId, sectionTop, scrollInfo.scrollBottom);\n        } else if (preInter && !curInter) {\n          // clear the section ID tracked in the page\n          removeActiveSection(trackingId, scrollInfo.scrollBottom);\n        }\n      }\n\n      preIntersecting.current = curInter;\n    },\n    [trackingId, isIntersecting, sectionTop, scrollInfo],\n  );\n\n  const scrolledRatio = useMemo(\n    () => {\n      const { scrollBottom } = scrollInfo;\n      const { height } = boundingRect;\n\n      const distance = scrollBottom - sectionTop;\n      let ratio = distance / height;\n\n      if (ratio >= 1) {\n        ratio = 1;\n      } else if (ratio <= 0) {\n        ratio = 0;\n      }\n\n      // if the section is tracked,\n      // let `useActiveSectionTracker()`to determine whether it is active,\n      // and if it is active, the scrolled ratio which it keeps track of will be updated\n      if (trackingId) {\n        updateScrollRatio(trackingId, ratio);\n      }\n\n      return ratio;\n    },\n    [trackingId, sectionTop, boundingRect, scrollInfo],\n  );\n\n  return {\n    isIntersecting,\n    scrolledRatio,\n    sectionTop,\n    scrollInfo,\n    boundingRect,\n  };\n}\n","import { useIntersectionObservable } from '../common/useIntersectionObservable';\n\nimport { useScrolledRatio } from './useScrolledRatio';\n\n/**\n * Return the `sectionInfo` of obtained from `useScrolledRatio()`\n */\nexport function useSection(\n  /** Ref of the section being tracked */\n  sectionRef: React.RefObject<HTMLElement>,\n\n  /**\n   * By setting an unique Section ID, you can know which section the user is currently viewing.\n   * If `trackingId` is not null,\n   * it will trigger the update of the active section infomation managed in `<Page>`.\n   * Please make sure that on the same `scrollTop`,\n   * there is **NO** more than one tracked section (section with `trackingId`).\n   */\n  trackingId?: string,\n) {\n  const intersectObsr$ = useIntersectionObservable(sectionRef, trackingId);\n  return useScrolledRatio(sectionRef, intersectObsr$, trackingId);\n}\n","import React, { useRef } from 'react';\n\nimport { SectionInfo } from '../hooks/section/useScrolledRatio';\nimport { useSection } from '../hooks/section/useSection';\n\nexport interface SectionProps {\n  /**\n   * By setting an unique Section ID, you can know which section the user is currently viewing.\n   * If `trackingId` is not null,\n   * `<Section>` will notify the `<PageProvider>` to keep track of the sections in the viewport,\n   * and determine which is closest to the bottom of the viewport.\n   * Please make sure that on the same `scrollTop`,\n   * there is **NO** more than one tracked section (section with `trackingId`).\n   */\n  trackingId?: string;\n\n  /**\n   * The array of intersectionRatio thresholds which is used in the options of IntersectionObserver\n   * @example [0, 0.25, 0.5, 0.75, 1]\n   */\n  threshold: number[] | 1;\n  className?: string;\n  style?: React.CSSProperties;\n  children: (section: SectionInfo) => React.ReactNode;\n}\n\nexport const Section = ({\n  className,\n  style,\n  children,\n  trackingId,\n  ...restProps\n}: SectionProps) => {\n  const sectionRef = useRef<HTMLDivElement>(null);\n  const sectionInfo = useSection(sectionRef, trackingId);\n\n  return (\n    <div\n      ref={sectionRef}\n      className={className}\n      style={style}\n      {...restProps}\n    >\n      {children(sectionInfo)}\n    </div>\n  );\n};\n","import { SectionInfo } from '../hooks/section/useScrolledRatio';\n\nconst STICKY_POS: {\n  absTop: React.CSSProperties,\n  fixed: React.CSSProperties,\n  absBottom: React.CSSProperties,\n} = {\n  absTop: {\n    position: 'absolute',\n    top: 0,\n    width: '100%',\n  },\n  fixed: {\n    position: 'fixed',\n    top: 0,\n  },\n  absBottom: {\n    position: 'absolute',\n    bottom: 0,\n    width: '100%',\n  },\n};\n\n/**\n * Returns the position of the inner div of the StickySection\n */\nexport function getStickyPosition(\n  section: SectionInfo,\n): React.CSSProperties {\n  const {\n    scrollInfo,\n    sectionTop,\n    boundingRect,\n  } = section;\n  const { scrollTop, scrollBottom } = scrollInfo;\n  const sectionBottom = sectionTop + boundingRect.height;\n  const stickyHeight = {\n    height: `${section.scrollInfo.windowHeight}px`,\n  };\n\n  if (scrollTop < sectionTop) {\n    // appears on the top of the page\n    return { ...stickyHeight, ...STICKY_POS.absTop };\n  }\n\n  if ((scrollTop >= sectionTop) && (sectionBottom > scrollBottom)) {\n    // sticks to the viewport\n    return {\n      ...stickyHeight,\n      ...STICKY_POS.fixed,\n      left: boundingRect.left,\n      width: boundingRect.width,\n    };\n  }\n\n  // appears on the bottom of the page\n  return { ...stickyHeight, ...STICKY_POS.absBottom };\n}\n","export * from './components/PageProvider';\nexport * from './components/Section';\nexport * from './context/PageContext';\nexport * from './utils/getIntersectionObserver';\nexport * from './utils/getStickyPosition';\nexport * from './hooks/page/useActiveSectionTracker';\nexport * from './hooks/common/useIntersectionObservable';\nexport * from './hooks/common/usePageScroll';\nexport * from './hooks/common/useSectionPosition';\nexport * from './hooks/section/useScrolledRatio';\nexport * from './hooks/section/useSection';\nexport * from './hooks/common/useSubscription';\n"],"sourceRoot":""}